/**
******************************************************************************
* @file     zc_cloud_event.c
* @authors  cxy
* @version  V1.0.0
* @date     10-Sep-2014
* @brief    Event
******************************************************************************
*/

#include <zc_common.h>
#include <zc_protocol_controller.h>
#include <zc_sec_engine.h>
extern 	char *optarg; 

u32 g_TraceSwitch = 0;

/*************************************************
* Function: ZC_TraceData
* Description: 
* Author: cxy 
* Returns: 
* Parameter: 
* History:
*************************************************/
void ZC_TraceData(u8* pData, u32 Len)
{
    u32 Index;
    ZC_Printf("++++++++++++++++++++++++++++++++++++++++++++++++\n");
    for (Index = 0; Index + 4 < Len; Index = Index + 4)
    {
        ZC_Printf("%02x %02x %02x %02x\n",
            pData[Index],
            pData[Index + 1],
            pData[Index + 2],
            pData[Index + 3]);
    }
    
    for (; Index < Len; Index++)
    {
        ZC_Printf("%02x ", pData[Index]);
    }
    
    ZC_Printf("\n++++++++++++++++++++++++++++++++++++++++++++++++\n");
}

#define  TESTLEN (70)
unsigned char output[TESTLEN];
unsigned char input[TESTLEN];
unsigned char finalput[TESTLEN];
R_RSA_PUBLIC_KEY PUBLIC_KEY1 = {
    512,
    {   0xdd,0x5d,0x99,0x31,
    0xa9,0x3c,0x20,0x33,
    0x0e,0x29,0x24,0x82,
    0x3b,0x34,0xcb,0x54,
    0xcf,0xf2,0x7b,0x0a,
    0x7f,0x45,0xaf,0x41,
    0xe4,0x7e,0x0b,0x5f,
    0x00,0x3f,0x29,0xfe,
    0x8d,0xfe,0xe9,0x5c,
    0x97,0x15,0x96,0x1f,
    0x73,0x13,0x87,0x2b,
    0x6a,0x2d,0xc1,0xec,
    0xe9,0x8e,0xdc,0x2b,
    0x20,0xff,0x4f,0x29,
    0x40,0x4c,0x70,0x74,
    0xd5,0x5e,0x9b,0x5b,
    },
    {
        0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x01,0x00,0x01
    }
};
R_RSA_PRIVATE_KEY PRIVATE_KEY1 = {
    512,
    {
        0xdd,0x5d,0x99,0x31,
            0xa9,0x3c,0x20,0x33,
            0x0e,0x29,0x24,0x82,
            0x3b,0x34,0xcb,0x54,
            0xcf,0xf2,0x7b,0x0a,
            0x7f,0x45,0xaf,0x41,
            0xe4,0x7e,0x0b,0x5f,
            0x00,0x3f,0x29,0xfe,
            0x8d,0xfe,0xe9,0x5c,
            0x97,0x15,0x96,0x1f,
            0x73,0x13,0x87,0x2b,
            0x6a,0x2d,0xc1,0xec,
            0xe9,0x8e,0xdc,0x2b,
            0x20,0xff,0x4f,0x29,
            0x40,0x4c,0x70,0x74,
            0xd5,0x5e,0x9b,0x5b
    },

    {
        0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,
            0x00,0x01,0x00,0x01
        },


        {
            0x8f,0x5c,0x4d,0x99,
                0x2e,0xdb,0xc4,0x92,
                0xac,0x0a,0x13,0x1d,
                0xd0,0x50,0x29,0x9a,
                0xbc,0xad,0x71,0xe7,
                0xe3,0x72,0xf2,0xc4,
                0x7e,0xc0,0xee,0x86,
                0x50,0xf7,0x97,0x2e,
                0x92,0xc8,0xdd,0xf9,
                0x61,0xb3,0xd7,0xc6,
                0x12,0x2b,0x8b,0x60,
                0xb3,0xbb,0xaf,0x50,
                0xba,0x09,0xfe,0x50,
                0xf9,0x84,0xf9,0xc9,
                0x11,0x5d,0xe5,0xa3,
                0xef,0x5b,0x4e,0x31
        },

        {
            {0xf3,0x12,0x4d,0xc8,
                0x43,0xbb,0x8b,0xa6,
                0x1f,0x03,0x5a,0x7d,
                0x09,0x38,0x25,0x1f,
                0x5d,0xd4,0xcb,0xfc,
                0x96,0xf5,0x45,0x3b,
                0x13,0x0d,0x89,0x0a,
                0x1c,0xdb,0xae,0x83},
            {0xe9,0x23,0xbe,0x84,
            0xe1,0x6c,0xd6,0xae,
            0x52,0x90,0x49,0xf1,
            0xf1,0xbb,0xe9,0xeb,
            0xb3,0xa6,0xdb,0x3c,
            0x87,0x0c,0x3e,0x99,
            0x24,0x5e,0x0d,0x1c,
            0x06,0xb7,0x48,0x49}
            },

            {    
                {0x45,0xfe,0xa7,0x57,
                    0x5b,0xe9,0xcd,0xb4,
                    0xf0,0x89,0x4e,0xad,
                    0x62,0xd2,0x40,0x1e,
                    0x60,0x2e,0xbe,0xee,
                    0xe5,0xa9,0x8b,0x5e,
                    0x0f,0x86,0x7e,0x47,
                    0xe3,0x37,0x7f,0x71},
                {0x04,0x2e,0x0e,0xe1,
                0x65,0x05,0x45,0x88,
                0x14,0x94,0xdf,0xae,
                0x85,0xcd,0xff,0xb0,
                0xa9,0x24,0xe9,0xb3,
                0x59,0x1c,0x80,0x16,
                0xd0,0xcf,0x1a,0xdf,
                0x10,0xc3,0xc2,0x79}
            },
            {
                0x3f,0x45,0x98,0xbc,
                    0x14,0x16,0x82,0xd0,
                    0x37,0xc5,0xce,0xe4,
                    0x05,0x34,0x4c,0x26,
                    0x63,0xe3,0x20,0xfc,
                    0x28,0x86,0x41,0xe0,
                    0x72,0xd4,0x6a,0x30,
                    0xd2,0xc2,0xa6,0x7c
            }
};

void TestSec()
{
    unsigned int outputLen;
    unsigned int finalputLen;
    unsigned int inputLen;
    unsigned int index;
    
    inputLen = 20;
    for (index = 0; index < 40; index++)
    {
        input[index]=index;
    }
    ZC_Printf("Here1\n");
    
    ZC_TraceData(input, inputLen);
    RSAPublicEncrypt(output, &outputLen, input, inputLen, &PUBLIC_KEY1, 0);
    ZC_Printf("Here2\n");
    ZC_TraceData(output, outputLen);
    ZC_Printf("Here3\n");    
    RSAPrivateDecrypt(finalput, &finalputLen, output, outputLen, &PRIVATE_KEY1);
    ZC_Printf("Here4\n");    
    ZC_TraceData(finalput, finalputLen);
}



void IoT_exec_AT_cmd_TraceSwitch(u8 *pCmdBuf, u16 at_cmd_len)
{
    TestSec();
#if 0
	INT16 argc = 0;
	char *argv[MAX_OPTION_COUNT];
	char *opString = "s:?";
	char opt=0;
	char *endptr;
	
	UINT8 switch_on=0;
	UINT8 content=0;
	
	memset(argv,0,4*MAX_OPTION_COUNT);
	
	split_string_cmd(pCmdBuf, at_cmd_len, &argc, argv);
	
	opt = getopt(argc, argv, opString);
	
	while (opt != -1)
	{
		switch (opt)
		{
    	case 's':
    		g_TraceSwitch = simple_strtol(optarg,&endptr,0);
    		break;

		default:
			break;
		}
		opt = getopt(argc, argv, opString);
	}
#endif
}

